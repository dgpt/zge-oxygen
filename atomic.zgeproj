<?xml version="1.0" encoding="utf-8"?>
<ZApplication Caption="atomic (all baselines & ranges externalized)">
  <Content>

    <!-- ========= ZGE Viz built-ins ========= -->
    <DefineArray    Name="SpecBandArray" SizeDim1="32"/>
    <DefineArray    Name="AudioArray"    SizeDim1="1024"/>
    <DefineVariable Name="SongPositionInBeats"/>

    <!-- ============================================================
         BASELINES / RANGES (edit these to retune global behavior)
         Each slider maps 0..1 â†’ [MIN..DEF..MAX] with a pivot at 0.5
         ============================================================ -->

    <!-- Audio drive -->
    <DefineVariable Name="BASE_GAIN_MIN"  Value="0.5"/>
    <DefineVariable Name="BASE_GAIN_DEF"  Value="1.0"/>
    <DefineVariable Name="BASE_GAIN_MAX"  Value="5.0"/>
    <DefineVariable Name="BASE_SENS_MIN"  Value="0.7"/>
    <DefineVariable Name="BASE_SENS_DEF"  Value="1.0"/>
    <DefineVariable Name="BASE_SENS_MAX"  Value="1.3"/>
    <!-- Gate & smoothing -->
    <DefineVariable Name="DRIVE_GATE"     Value="0.18"/>   <!-- below => 0 -->
    <DefineVariable Name="DRIVE_LP_ALPHA" Value="0.94"/>   <!-- closer 1 = smoother -->
    <!-- Orbital base Hz (before AnimSpeed) -->
    <DefineVariable Name="BASE_ORB_HZ_MIN" Value="0.05"/>
    <DefineVariable Name="BASE_ORB_HZ_MAX" Value="0.35"/>
    <!-- AnimSpeed scalar -->
    <DefineVariable Name="BASE_AS_MIN"    Value="0.02"/>
    <DefineVariable Name="BASE_AS_DEF"    Value="0.18"/>
    <DefineVariable Name="BASE_AS_MAX"    Value="0.40"/>
    <!-- Smoothness (easing width / swirl damping) -->
    <DefineVariable Name="BASE_SM_MIN"    Value="0.0"/>
    <DefineVariable Name="BASE_SM_DEF"    Value="0.70"/>
    <DefineVariable Name="BASE_SM_MAX"    Value="1.0"/>

    <!-- Engine controls -->
    <DefineVariable Name="BASE_ORBS_MIN"  Value="0.20"/>
    <DefineVariable Name="BASE_ORBS_DEF"  Value="0.50"/>
    <DefineVariable Name="BASE_ORBS_MAX"  Value="1.20"/>

    <DefineVariable Name="BASE_DENS_MIN"  Value="0.50"/>
    <DefineVariable Name="BASE_DENS_DEF"  Value="1.25"/>
    <DefineVariable Name="BASE_DENS_MAX"  Value="2.50"/>

    <DefineVariable Name="BASE_WISP_MIN"  Value="0.00"/>
    <DefineVariable Name="BASE_WISP_DEF"  Value="0.28"/>
    <DefineVariable Name="BASE_WISP_MAX"  Value="0.50"/>

    <!-- Quality (step length multiplier): smaller = better -->
    <DefineVariable Name="BASE_Q_BEST"    Value="0.50"/>   <!-- best quality -->
    <DefineVariable Name="BASE_Q_DEF"     Value="1.00"/>
    <DefineVariable Name="BASE_Q_WORST"   Value="2.00"/>   <!-- worst quality -->

    <!-- Nucleus -->
    <DefineVariable Name="BASE_NR_MIN"    Value="0.03"/>
    <DefineVariable Name="BASE_NR_DEF"    Value="0.08"/>
    <DefineVariable Name="BASE_NR_MAX"    Value="0.15"/>

    <DefineVariable Name="BASE_NDOT_MIN"  Value="0.004"/>
    <DefineVariable Name="BASE_NDOT_DEF"  Value="0.016"/>
    <DefineVariable Name="BASE_NDOT_MAX"  Value="0.040"/>

    <!-- Twinkle pacing (Hz per electron at Drive=0) -->
    <DefineVariable Name="BASE_TW_MIN"    Value="0.05"/>
    <DefineVariable Name="BASE_TW_DEF"    Value="0.40"/>
    <DefineVariable Name="BASE_TW_MAX"    Value="2.00"/>

    <!-- Color defaults (midpoint = DEF_*) and bounds for mapping -->
    <!-- Hue uses [0..360], others [0..1] -->
    <DefineVariable Name="DEF_BGH"  Value="210.0"/>
    <DefineVariable Name="DEF_BGS"  Value="0.45"/>
    <DefineVariable Name="DEF_BGL"  Value="0.015"/>
    <DefineVariable Name="DEF_BGA"  Value="1.0"/>

    <DefineVariable Name="DEF_PosH" Value="190.0"/>
    <DefineVariable Name="DEF_PosS" Value="0.90"/>
    <DefineVariable Name="DEF_PosL" Value="0.62"/>
    <DefineVariable Name="DEF_PosA" Value="1.0"/>

    <DefineVariable Name="DEF_NegH" Value="325.0"/>
    <DefineVariable Name="DEF_NegS" Value="0.85"/>
    <DefineVariable Name="DEF_NegL" Value="0.60"/>
    <DefineVariable Name="DEF_NegA" Value="1.0"/>

    <DefineVariable Name="DEF_ProtH" Value="28.0"/>
    <DefineVariable Name="DEF_ProtS" Value="0.95"/>
    <DefineVariable Name="DEF_ProtL" Value="0.72"/>
    <DefineVariable Name="DEF_ProtA" Value="1.0"/>

    <DefineVariable Name="DEF_NeutH" Value="260.0"/>
    <DefineVariable Name="DEF_NeutS" Value="0.65"/>
    <DefineVariable Name="DEF_NeutL" Value="0.75"/>
    <DefineVariable Name="DEF_NeutA" Value="1.0"/>

    <DefineVariable Name="DEF_ElecH" Value="190.0"/>
    <DefineVariable Name="DEF_ElecS" Value="0.98"/>
    <DefineVariable Name="DEF_ElecL" Value="0.92"/>
    <DefineVariable Name="DEF_ElecA" Value="1.0"/>

    <!-- ====== UI Sliders ====== -->
    <DefineArray Name="Parameters" SizeDim1="35"/>
    <DefineConstant Name="ParamHelpConst" Type="2"
      StringValue="Audio Gain&#10;Sensitivity&#10;Smoothness&#10;Animation Speed&#10;Orbital Size&#10;Density Gain&#10;Wisp Strength&#10;Quality&#10;Nucleus Radius&#10;Nucleus Dot Size&#10;Twinkle Base Rate&#10;BG Hue&#10;BG Sat&#10;BG Light&#10;BG Alpha&#10;POS Hue&#10;POS Sat&#10;POS Light&#10;POS Alpha&#10;NEG Hue&#10;NEG Sat&#10;NEG Light&#10;NEG Alpha&#10;Proton Hue&#10;Proton Sat&#10;Proton Light&#10;Proton Alpha&#10;Neutron Hue&#10;Neutron Sat&#10;Neutron Light&#10;Neutron Alpha&#10;Electron Hue&#10;Electron Sat&#10;Electron Light&#10;Electron Alpha"/>

    <!-- ====== Runtime state / uniforms ====== -->
    <DefineVariable Name="Drive"     Value="0.0"/>
    <DefineVariable Name="uTimeVar"  Value="0.0"/>
    <DefineVariable Name="Aspect"    Value="1.777778"/>

    <!-- exposed engine values (driven from sliders) -->
    <DefineVariable Name="Smooth"    Value="0.70"/>
    <DefineVariable Name="AnimSpeed" Value="0.18"/>
    <DefineVariable Name="OrbScale"  Value="0.50"/>
    <DefineVariable Name="Density"   Value="1.25"/>
    <DefineVariable Name="Wisp"      Value="0.28"/>
    <DefineVariable Name="StepMul"   Value="1.00"/>
    <DefineVariable Name="NucR"      Value="0.08"/>
    <DefineVariable Name="NucDot"    Value="0.016"/>
    <DefineVariable Name="TwBase"    Value="0.40"/>

    <!-- Phase integrator -->
    <DefineVariable Name="Phase"     Value="0.0"/>
    <DefineVariable Name="HzSmooth"  Value="0.10"/>

    <!-- HSLA uniforms -->
    <DefineVariable Name="uBGH" Value="210.0"/>
    <DefineVariable Name="uBGS" Value="0.45"/>
    <DefineVariable Name="uBGL" Value="0.015"/>
    <DefineVariable Name="uBGA" Value="1.0"/>

    <DefineVariable Name="uPosH" Value="190.0"/>
    <DefineVariable Name="uPosS" Value="0.90"/>
    <DefineVariable Name="uPosL" Value="0.62"/>
    <DefineVariable Name="uPosA" Value="1.0"/>

    <DefineVariable Name="uNegH" Value="325.0"/>
    <DefineVariable Name="uNegS" Value="0.85"/>
    <DefineVariable Name="uNegL" Value="0.60"/>
    <DefineVariable Name="uNegA" Value="1.0"/>

    <DefineVariable Name="uProtH" Value="28.0"/>
    <DefineVariable Name="uProtS" Value="0.95"/>
    <DefineVariable Name="uProtL" Value="0.72"/>
    <DefineVariable Name="uProtA" Value="1.0"/>

    <DefineVariable Name="uNeutH" Value="260.0"/>
    <DefineVariable Name="uNeutS" Value="0.65"/>
    <DefineVariable Name="uNeutL" Value="0.75"/>
    <DefineVariable Name="uNeutA" Value="1.0"/>

    <DefineVariable Name="uElecH" Value="190.0"/>
    <DefineVariable Name="uElecS" Value="0.98"/>
    <DefineVariable Name="uElecL" Value="0.92"/>
    <DefineVariable Name="uElecA" Value="1.0"/>

    <!-- ================= Shader ================= -->
    <Shader Name="ScreenShader">
      <VertexShaderSource><![CDATA[
#version 120
varying vec2 vUv;
void main(){
  vUv = gl_MultiTexCoord0.xy;
  gl_Position = ftransform();
}
      ]]></VertexShaderSource>

      <FragmentShaderSource><![CDATA[
#version 120
varying vec2 vUv;

uniform float uTime, uDrive, uSmooth, uAnimSpeed, uAspect, uPhase;

/* user uniforms */
uniform float uOrbScale, uDensity, uWisp, uStepMul;
uniform float uNucR, uNucDot, uTwBase;

/* HSLA uniforms */
uniform float uBGH,uBGS,uBGL,uBGA;
uniform float uPosH,uPosS,uPosL,uPosA;
uniform float uNegH,uNegS,uNegL,uNegA;
uniform float uProtH,uProtS,uProtL,uProtA;
uniform float uNeutH,uNeutS,uNeutL,uNeutA;
uniform float uElecH,uElecS,uElecL,uElecA;

/* constants for volume render */
const float ZOOM=1.0;
const float HALF_Z=2.5;
const int   VOL_STEPS = 96;
const float STEP_LEN0 = (2.0*HALF_Z)/float(VOL_STEPS);

const float ORB_S_1S=0.80, ORB_S_2S=0.30, ORB_S_2P=0.25, ORB_S_3D=0.25;
const float ORB_AUDIO_EXPAND=0.50;

const float DENS_PEAK_GAIN=2.0;

const float PROTONS=8.0, NEUTRONS=8.0;
const float NUC_JITTER=0.35;
const float ELECTRONS=8.0;
const float TWIN_MAX_GAIN=3.5, TWIN_HALO=2.2, TWIN_GAIN0=2.6;

const int NUC_MAX=64;
const float TAU=6.28318530718;

/* utils */
float hash1(float x){ return fract(sin(x*113.3189)*43758.5453); }
vec3 hsl2rgb(vec3 h){
  float H=h.x/360.0,S=clamp(h.y,0.0,1.0),L=clamp(h.z,0.0,1.0);
  float C=(1.0-abs(2.0*L-1.0))*S, X=C*(1.0-abs(mod(H*6.0,2.0)-1.0));
  vec3  rgb=(H<1./6.)?vec3(C,X,0):(H<2./6.)?vec3(X,C,0):(H<3./6.)?vec3(0,C,X):
             (H<4./6.)?vec3(0,X,C):(H<5./6.)?vec3(X,0,C):vec3(C,0,X);
  return rgb + (L-0.5*C);
}
vec2 uv01(){ return vUv; }
vec2 uvHNorm(){ return (uv01()*2.0 - 1.0) * vec2(uAspect,1.0); }

/* spherical harmonics l<=2 + simple radial */
void cart2sph(vec3 p, out float r, out float th, out float ph){
  r=length(p); th=(r>0.0)?acos(clamp(p.z/r,-1.0,1.0)):0.0; ph=atan(p.y,p.x);
}
float Y00(float th,float ph){return 1.0;}
float Y1m1(float th,float ph){return sin(th)*sin(ph);}
float Y10 (float th,float ph){return cos(th);}
float Y11 (float th,float ph){return sin(th)*cos(ph);}
float Y20 (float th,float ph){return 0.5*(3.0*cos(th)*cos(th)-1.0);}
float Y21 (float th,float ph){return sin(th)*cos(th)*cos(ph);} /* proxy */

float R10(float r){ return exp(-r); }
float R20(float r){ return (2.0 - r)*exp(-r*0.5); }
float R21(float r){ return r*exp(-r*0.5); }
float R32(float r){ return r*r*exp(-r/3.0); }

float famScale(int s){
  if(s==0) return ORB_S_1S;
  if(s==1) return ORB_S_2S;
  if(s==2||s==3||s==4) return ORB_S_2P;
  return ORB_S_3D;
}

vec3 swirl(vec3 p, float d){
  float amp = (0.20 + 0.50*d) * mix(1.0, 0.6, uSmooth);
  float spd = 0.31 * mix(1.0, 0.6, uSmooth);
  float s = sin(spd*uTime + 0.7*d), c = cos(spd*uTime + 0.7*d);
  vec3 q = vec3( c*p.x + s*p.z, p.y, -s*p.x + c*p.z );
  float w = 0.20 * mix(1.0, 0.6, uSmooth)
          * sin( (q.y*1.3 + q.x*0.7 + q.z*0.9) * 2.7 + 0.9*uTime );
  return mix(p, q + w*normalize(vec3(q.x+0.001, q.y-0.002, q.z+0.003)), amp);
}

float psiAt(int s, vec3 p, float drive){
  float sc = max(1e-3, uOrbScale * famScale(s) * (1.0 + ORB_AUDIO_EXPAND*drive));
  vec3  q  = swirl(p/sc, drive);
  float r,th,ph; cart2sph(q,r,th,ph);
  if(s==0) return Y00(th,ph)*R10(r);
  if(s==1) return Y00(th,ph)*R20(r);
  if(s==2) return Y11(th,ph)*R21(r);
  if(s==3) return Y1m1(th,ph)*R21(r);
  if(s==4) return Y10(th,ph)*R21(r);
  if(s==5) return Y20(th,ph)*R32(r);
  return      Y21(th,ph)*R32(r);
}

float psiMix(vec3 p, float state, float drive){
  const int COUNT=7;
  float idx=floor(state), t=fract(state);
  float tEase = mix(t, t*t*(3.0 - 2.0*t), uSmooth);
  float width = mix(0.20, 0.90, uSmooth);
  int s0=int(mod(idx, float(COUNT)));
  int s1=int(mod(idx+1.0, float(COUNT)));
  float a0=psiAt(s0,p,drive), a1=psiAt(s1,p,drive);
  float ts=smoothstep(0.5-width*0.5, 0.5+width*0.5, tEase);
  return mix(a0,a1,ts);
}

float wispMod(vec3 p, float d){
  float wg = uWisp * mix(1.0, 0.6, uSmooth);
  float w1 = sin(dot(p, vec3(1.2,1.7,2.1))*3.2 + (0.8+1.2*d)*uTime);
  float w2 = sin(dot(p, vec3(-1.3,2.0,-0.8))*7.0 + (1.1+1.7*d)*uTime)*0.5;
  return max(0.0, 1.0 + wg*(w1 + w2));
}

/* colors */
vec3  bgRGB()   { return hsl2rgb(vec3(uBGH,uBGS,uBGL))*uBGA; }
vec3  posRGB()  { return hsl2rgb(vec3(uPosH,uPosS,uPosL))*uPosA; }
vec3  negRGB()  { return hsl2rgb(vec3(uNegH,uNegS,uNegL))*uNegA; }
vec4  protHSLA(){ return vec4(hsl2rgb(vec3(uProtH,uProtS,uProtL)), uProtA); }
vec4  neutHSLA(){ return vec4(hsl2rgb(vec3(uNeutH,uNeutS,uNeutL)), uNeutA); }
vec4  elecHSLA(){ return vec4(hsl2rgb(vec3(uElecH,uElecS,uElecL)), uElecA); }

vec3 nucleus(vec2 uv01){
  vec3 col=vec3(0.0); int NP=int(PROTONS+0.5), NN=int(NEUTRONS+0.5), NT=NP+NN;
  if(NT<1) return col; if(NT>NUC_MAX) NT=NUC_MAX;
  float jitter = NUC_JITTER * mix(1.0, 0.4, uSmooth);
  vec4 pHSLA = protHSLA();
  vec4 nHSLA = neutHSLA();
  for(int k=0;k<NUC_MAX;k++){
    if(k>=NT) break;
    float m=float(k)+0.5;
    float z = 1.0 - 2.0*m/float(NT);
    float r = sqrt(max(0.0,1.0 - z*z));
    float th= 2.3999632297 * m;
    vec3 p = vec3(r*cos(th), r*sin(th), z) * uNucR;

    vec3 j = vec3(
      sin(1.9*uTime + 4.1*hash1(5.7*m)),
      sin(1.7*uTime + 3.3*hash1(7.9*m)),
      sin(2.1*uTime + 2.9*hash1(9.3*m))
    ) * (jitter * uNucR);
    p += j;

    vec2 n01 = (p.xy * ZOOM) / vec2(uAspect,1.0) * 0.5 + 0.5;
    float sigma = uNucDot * ZOOM;
    float d = length(uv01 - n01);
    float g = exp(-pow(d/(sigma+1e-6),2.0));
    vec3 c = (k<NP) ? pHSLA.rgb*pHSLA.a : nHSLA.rgb*nHSLA.a;
    col += c*g;
  }
  return col;
}

vec3 twinkle(float drive, float state){
  vec4 eHSLA = elecHSLA();
  float E=max(1.0,ELECTRONS);
  float rate=uTwBase*(1.0+3.5*drive)*E * mix(1.0, 0.5, uSmooth);
  float ticks=floor(uTime*rate), idx=mod(ticks,E), ph=fract(uTime*rate);
  float env=smoothstep(0.00,0.30,ph)*(1.0 - smoothstep(0.70,1.0,ph));
  vec3 best=vec3(0.0); float bestDen=-1.0;
  for(int c=0;c<8;c++){
    float seed=(idx+1.0)*31.0 + ticks*13.0 + float(c)*97.0;
    float u1=hash1(seed), u2=hash1(seed*1.37), u3=hash1(seed*2.17);
    float cz=clamp(2.0*u1-1.0,-1.0,1.0), az=acos(cz), ang=TAU*u2;
    vec3 dir=vec3(sin(az)*cos(ang), sin(az)*sin(ang), cz);
    float nHint=1.0+mod(state,3.0);
    float radius=-log(max(1e-4,u3))*(0.25*nHint);
    vec3 p=dir*radius;
    float den=psiMix(p,state,drive); den*=den;
    if(den>bestDen){ bestDen=den; best=p; }
  }
  vec2 e01=(best.xy*ZOOM)/vec2(uAspect,1.0)*0.5+0.5;
  float size=0.0007*ZOOM*(1.0+0.7*drive);
  float d=length(uv01()-e01);
  float g=exp(-pow(d/(size+1e-6),2.0))*env;
  float h=exp(-pow(d/((size)*TWIN_HALO+1e-6),2.0))*env;
  return eHSLA.rgb*(eHSLA.a*(g*2.2+0.7*h)*TWIN_GAIN0*(1.0+1.8*drive));
}

void main(){
  vec3 col = bgRGB();

  float d  = clamp(uDrive, 0.0, 1.0);
  float st = uPhase;

  float stepLen = STEP_LEN0 * max(0.5, uStepMul);
  float kComp   = STEP_LEN0 / stepLen;

  vec3  ro = vec3(uvHNorm()/max(ZOOM,1e-3), -HALF_Z);
  vec3  rd = vec3(0,0,1);
  float T  = 1.0;
  vec3  acc= vec3(0.0);

  vec3 cPos = posRGB();
  vec3 cNeg = negRGB();

  for(int i=0;i<VOL_STEPS;i++){
    float z = -HALF_Z + (float(i)+0.5)*stepLen;
    vec3  p = ro + rd*(z+HALF_Z);
    float psi = psiMix(p, st, d);
    float pos = max(psi, 0.0), neg = max(-psi, 0.0);
    float rPos= pos*pos, rNeg=neg*neg;

    float rho = (rPos + rNeg) * wispMod(p, d);

    float k    = uDensity * (1.0 + 2.0*d) * kComp;
    float a    = 1.0 - exp(-k * rho * stepLen);
    a = clamp(a, 0.0, 1.0);

    float wsum = rPos + rNeg + 1e-6;
    vec3  tint = (cPos*(rPos/wsum) + cNeg*(rNeg/wsum));

    vec3  contrib = tint * a;
    acc += T * contrib;
    T   *= (1.0 - a);
    if(T < 0.02) break;
  }

  col += acc;
  col += nucleus(uv01());
  col += twinkle(d, st);

  col = 1.0 - exp(-min(col, vec3(24.0)));
  col = pow(col, vec3(1.0/2.2));
  gl_FragColor = vec4(col,1.0);
}
      ]]></FragmentShaderSource>

      <UniformVariables>
        <ShaderVariable VariableName="uTime"       VariableRef="uTimeVar"/>
        <ShaderVariable VariableName="uDrive"      VariableRef="Drive"/>
        <ShaderVariable VariableName="uSmooth"     VariableRef="Smooth"/>
        <ShaderVariable VariableName="uAnimSpeed"  VariableRef="AnimSpeed"/>
        <ShaderVariable VariableName="uAspect"     VariableRef="Aspect"/>
        <ShaderVariable VariableName="uPhase"      VariableRef="Phase"/>

        <ShaderVariable VariableName="uOrbScale"   VariableRef="OrbScale"/>
        <ShaderVariable VariableName="uDensity"    VariableRef="Density"/>
        <ShaderVariable VariableName="uWisp"       VariableRef="Wisp"/>
        <ShaderVariable VariableName="uStepMul"    VariableRef="StepMul"/>

        <ShaderVariable VariableName="uNucR"       VariableRef="NucR"/>
        <ShaderVariable VariableName="uNucDot"     VariableRef="NucDot"/>
        <ShaderVariable VariableName="uTwBase"     VariableRef="TwBase"/>

        <ShaderVariable VariableName="uBGH" VariableRef="uBGH"/>
        <ShaderVariable VariableName="uBGS" VariableRef="uBGS"/>
        <ShaderVariable VariableName="uBGL" VariableRef="uBGL"/>
        <ShaderVariable VariableName="uBGA" VariableRef="uBGA"/>

        <ShaderVariable VariableName="uPosH" VariableRef="uPosH"/>
        <ShaderVariable VariableName="uPosS" VariableRef="uPosS"/>
        <ShaderVariable VariableName="uPosL" VariableRef="uPosL"/>
        <ShaderVariable VariableName="uPosA" VariableRef="uPosA"/>

        <ShaderVariable VariableName="uNegH" VariableRef="uNegH"/>
        <ShaderVariable VariableName="uNegS" VariableRef="uNegS"/>
        <ShaderVariable VariableName="uNegL" VariableRef="uNegL"/>
        <ShaderVariable VariableName="uNegA" VariableRef="uNegA"/>

        <ShaderVariable VariableName="uProtH" VariableRef="uProtH"/>
        <ShaderVariable VariableName="uProtS" VariableRef="uProtS"/>
        <ShaderVariable VariableName="uProtL" VariableRef="uProtL"/>
        <ShaderVariable VariableName="uProtA" VariableRef="uProtA"/>

        <ShaderVariable VariableName="uNeutH" VariableRef="uNeutH"/>
        <ShaderVariable VariableName="uNeutS" VariableRef="uNeutS"/>
        <ShaderVariable VariableName="uNeutL" VariableRef="uNeutL"/>
        <ShaderVariable VariableName="uNeutA" VariableRef="uNeutA"/>

        <ShaderVariable VariableName="uElecH" VariableRef="uElecH"/>
        <ShaderVariable VariableName="uElecS" VariableRef="uElecS"/>
        <ShaderVariable VariableName="uElecL" VariableRef="uElecL"/>
        <ShaderVariable VariableName="uElecA" VariableRef="uElecA"/>
      </UniformVariables>
    </Shader>

    <Material Name="Mat" Shader="ScreenShader"/>

  </Content>

  <!-- ================= Per-frame ================= -->
  <OnRender>

    <!-- time -->
    <ZExpression><Expression><![CDATA[
uTimeVar = uTimeVar + 0.016;
]]></Expression></ZExpression>

    <!-- Smoothness -->
    <ZExpression><Expression><![CDATA[
float p = Parameters[2];
if (p < 0.5)
  Smooth = BASE_SM_MIN + (BASE_SM_DEF - BASE_SM_MIN) * (p * 2.0);
else
  Smooth = BASE_SM_DEF + (BASE_SM_MAX - BASE_SM_DEF) * (p * 2.0 - 1.0);
]]></Expression></ZExpression>

    <!-- Animation Speed -->
    <ZExpression><Expression><![CDATA[
float a = Parameters[3];
if (a < 0.5)
  AnimSpeed = BASE_AS_MIN + (BASE_AS_DEF - BASE_AS_MIN) * (a * 2.0);
else
  AnimSpeed = BASE_AS_DEF + (BASE_AS_MAX - BASE_AS_DEF) * (a * 2.0 - 1.0);
]]></Expression></ZExpression>

    <!-- Audio drive (gain, sensitivity, gate, LP) -->
    <ZExpression><Expression><![CDATA[
float g = Parameters[0];
float gain = (g < 0.5) ? (BASE_GAIN_MIN + (BASE_GAIN_DEF - BASE_GAIN_MIN)*(g*2.0))
                       : (BASE_GAIN_DEF + (BASE_GAIN_MAX - BASE_GAIN_DEF)*(g*2.0-1.0));

float s = Parameters[1];
float mult = (s < 0.5) ? (BASE_SENS_MIN + (BASE_SENS_DEF - BASE_SENS_MIN)*(s*2.0))
                       : (BASE_SENS_DEF + (BASE_SENS_MAX - BASE_SENS_DEF)*(s*2.0-1.0));

/* 5-band average */
float b1=SpecBandArray[1];  if(b1<0.0)b1=-b1;
float b3=SpecBandArray[3];  if(b3<0.0)b3=-b3;
float b6=SpecBandArray[6];  if(b6<0.0)b6=-b6;
float b10=SpecBandArray[10];if(b10<0.0)b10=-b10;
float b15=SpecBandArray[15];if(b15<0.0)b15=-b15;
float sAvg = (b1+b3+b6+b10+b15)/5.0;

float raw = sAvg * gain * mult;
if (raw < DRIVE_GATE) raw = 0.0;
if (raw > 1.0) raw = 1.0;

Drive = Drive * DRIVE_LP_ALPHA + raw * (1.0 - DRIVE_LP_ALPHA);

/* integrate phase at slow rates */
float targetHz = (BASE_ORB_HZ_MIN + (BASE_ORB_HZ_MAX - BASE_ORB_HZ_MIN) * Drive) * AnimSpeed;
HzSmooth = HzSmooth * 0.97 + targetHz * 0.03;
Phase    = Phase + HzSmooth * 0.016;
]]></Expression></ZExpression>

    <!-- Engine sliders -->
    <ZExpression><Expression><![CDATA[
float v;

/* Orbital size */
v = Parameters[4];
if (v < 0.5) OrbScale = BASE_ORBS_MIN + (BASE_ORBS_DEF - BASE_ORBS_MIN) * (v * 2.0);
else         OrbScale = BASE_ORBS_DEF + (BASE_ORBS_MAX - BASE_ORBS_DEF) * (v * 2.0 - 1.0);

/* Density gain */
v = Parameters[5];
if (v < 0.5) Density = BASE_DENS_MIN + (BASE_DENS_DEF - BASE_DENS_MIN) * (v * 2.0);
else         Density = BASE_DENS_DEF + (BASE_DENS_MAX - BASE_DENS_DEF) * (v * 2.0 - 1.0);

/* Wisp strength */
v = Parameters[6];
if (v < 0.5) Wisp = BASE_WISP_MIN + (BASE_WISP_DEF - BASE_WISP_MIN) * (v * 2.0);
else         Wisp = BASE_WISP_DEF + (BASE_WISP_MAX - BASE_WISP_DEF) * (v * 2.0 - 1.0);

/* Quality (inverse mapping: worstâ†’best) */
v = Parameters[7];
if (v < 0.5) StepMul = BASE_Q_WORST + (BASE_Q_DEF   - BASE_Q_WORST) * (v * 2.0);
else         StepMul = BASE_Q_DEF   + (BASE_Q_BEST  - BASE_Q_DEF)   * (v * 2.0 - 1.0);

/* Nucleus radius */
v = Parameters[8];
if (v < 0.5) NucR = BASE_NR_MIN + (BASE_NR_DEF - BASE_NR_MIN) * (v * 2.0);
else         NucR = BASE_NR_DEF + (BASE_NR_MAX - BASE_NR_DEF) * (v * 2.0 - 1.0);

/* Nucleus dot size */
v = Parameters[9];
if (v < 0.5) NucDot = BASE_NDOT_MIN + (BASE_NDOT_DEF - BASE_NDOT_MIN) * (v * 2.0);
else         NucDot = BASE_NDOT_DEF + (BASE_NDOT_MAX - BASE_NDOT_DEF) * (v * 2.0 - 1.0);

/* Twinkle Base Rate */
v = Parameters[10];
if (v < 0.5) TwBase = BASE_TW_MIN + (BASE_TW_DEF - BASE_TW_MIN) * (v * 2.0);
else         TwBase = BASE_TW_DEF + (BASE_TW_MAX - BASE_TW_DEF) * (v * 2.0 - 1.0);
]]></Expression></ZExpression>

    <!-- HSLA (0.5 = DEF_*) -->
    <ZExpression><Expression><![CDATA[
float q;
/* BG */
q = Parameters[11];  if(q<0.5) uBGH = 0.0 + (DEF_BGH - 0.0)*(q*2.0); else uBGH = DEF_BGH + (360.0-DEF_BGH)*(q*2.0-1.0);
q = Parameters[12];  if(q<0.5) uBGS = 0.0 + (DEF_BGS - 0.0)*(q*2.0); else uBGS = DEF_BGS + (1.0-DEF_BGS)*(q*2.0-1.0);
q = Parameters[13];  if(q<0.5) uBGL = 0.0 + (DEF_BGL - 0.0)*(q*2.0); else uBGL = DEF_BGL + (1.0-DEF_BGL)*(q*2.0-1.0);
q = Parameters[14];  if(q<0.5) uBGA = 0.0 + (DEF_BGA - 0.0)*(q*2.0); else uBGA = DEF_BGA + (1.0-DEF_BGA)*(q*2.0-1.0);
/* POS */
q = Parameters[15];  if(q<0.5) uPosH= 0.0 + (DEF_PosH-0.0)*(q*2.0);  else uPosH=DEF_PosH + (360.0-DEF_PosH)*(q*2.0-1.0);
q = Parameters[16];  if(q<0.5) uPosS= 0.0 + (DEF_PosS-0.0)*(q*2.0);  else uPosS=DEF_PosS + (1.0-DEF_PosS)*(q*2.0-1.0);
q = Parameters[17];  if(q<0.5) uPosL= 0.0 + (DEF_PosL-0.0)*(q*2.0);  else uPosL=DEF_PosL + (1.0-DEF_PosL)*(q*2.0-1.0);
q = Parameters[18];  if(q<0.5) uPosA= 0.0 + (DEF_PosA-0.0)*(q*2.0);  else uPosA=DEF_PosA + (1.0-DEF_PosA)*(q*2.0-1.0);
/* NEG */
q = Parameters[19];  if(q<0.5) uNegH= 0.0 + (DEF_NegH-0.0)*(q*2.0);  else uNegH=DEF_NegH + (360.0-DEF_NegH)*(q*2.0-1.0);
q = Parameters[20];  if(q<0.5) uNegS= 0.0 + (DEF_NegS-0.0)*(q*2.0);  else uNegS=DEF_NegS + (1.0-DEF_NegS)*(q*2.0-1.0);
q = Parameters[21];  if(q<0.5) uNegL= 0.0 + (DEF_NegL-0.0)*(q*2.0);  else uNegL=DEF_NegL + (1.0-DEF_NegL)*(q*2.0-1.0);
q = Parameters[22];  if(q<0.5) uNegA= 0.0 + (DEF_NegA-0.0)*(q*2.0);  else uNegA=DEF_NegA + (1.0-DEF_NegA)*(q*2.0-1.0);
/* Proton */
q = Parameters[23];  if(q<0.5) uProtH=0.0 + (DEF_ProtH-0.0)*(q*2.0); else uProtH=DEF_ProtH + (360.0-DEF_ProtH)*(q*2.0-1.0);
q = Parameters[24];  if(q<0.5) uProtS=0.0 + (DEF_ProtS-0.0)*(q*2.0); else uProtS=DEF_ProtS + (1.0-DEF_ProtS)*(q*2.0-1.0);
q = Parameters[25];  if(q<0.5) uProtL=0.0 + (DEF_ProtL-0.0)*(q*2.0); else uProtL=DEF_ProtL + (1.0-DEF_ProtL)*(q*2.0-1.0);
q = Parameters[26];  if(q<0.5) uProtA=0.0 + (DEF_ProtA-0.0)*(q*2.0); else uProtA=DEF_ProtA + (1.0-DEF_ProtA)*(q*2.0-1.0);
/* Neutron */
q = Parameters[27];  if(q<0.5) uNeutH=0.0 + (DEF_NeutH-0.0)*(q*2.0); else uNeutH=DEF_NeutH + (360.0-DEF_NeutH)*(q*2.0-1.0);
q = Parameters[28];  if(q<0.5) uNeutS=0.0 + (DEF_NeutS-0.0)*(q*2.0); else uNeutS=DEF_NeutS + (1.0-DEF_NeutS)*(q*2.0-1.0);
q = Parameters[29];  if(q<0.5) uNeutL=0.0 + (DEF_NeutL-0.0)*(q*2.0); else uNeutL=DEF_NeutL + (1.0-DEF_NeutL)*(q*2.0-1.0);
q = Parameters[30];  if(q<0.5) uNeutA=0.0 + (DEF_NeutA-0.0)*(q*2.0); else uNeutA=DEF_NeutA + (1.0-DEF_NeutA)*(q*2.0-1.0);
/* Electron */
q = Parameters[31];  if(q<0.5) uElecH=0.0 + (DEF_ElecH-0.0)*(q*2.0); else uElecH=DEF_ElecH + (360.0-DEF_ElecH)*(q*2.0-1.0);
q = Parameters[32];  if(q<0.5) uElecS=0.0 + (DEF_ElecS-0.0)*(q*2.0); else uElecS=DEF_ElecS + (1.0-DEF_ElecS)*(q*2.0-1.0);
q = Parameters[33];  if(q<0.5) uElecL=0.0 + (DEF_ElecL-0.0)*(q*2.0); else uElecL=DEF_ElecL + (1.0-DEF_ElecL)*(q*2.0-1.0);
q = Parameters[34];  if(q<0.5) uElecA=0.0 + (DEF_ElecA-0.0)*(q*2.0); else uElecA=DEF_ElecA + (1.0-DEF_ElecA)*(q*2.0-1.0);
]]></Expression></ZExpression>

    <!-- Fullscreen draw via your scaling group -->
    <UseMaterial Material="Mat"/>
    <RenderTransformGroup Scale="20 20 1">
      <Children><RenderSprite/></Children>
    </RenderTransformGroup>

  </OnRender>
</ZApplication>
