<?xml version="1.0" encoding="utf-8"?>
<ZApplication Caption="atomic (all baselines &amp; ranges externalized)">
  <Content>

    <!-- ========= ZGE Viz built-ins ========= -->
    <DefineArray    Name="SpecBandArray" SizeDim1="32"/>
    <DefineArray    Name="AudioArray"    SizeDim1="1024"/>
    <DefineVariable Name="SongPositionInBeats"/>

    <!-- ============================================================
         BASELINES / RANGES (edit these to retune global behavior)
         Each slider maps 0..1 â†’ [MIN..DEF..MAX] with a pivot at 0.5
         ============================================================ -->

    <!-- Audio drive -->
    <DefineVariable Name="BASE_GAIN_MIN"  Value="0.5"/>
    <DefineVariable Name="BASE_GAIN_DEF"  Value="1.0"/>
    <DefineVariable Name="BASE_GAIN_MAX"  Value="5.0"/>
    <DefineVariable Name="BASE_SENS_MIN"  Value="0.7"/>
    <DefineVariable Name="BASE_SENS_DEF"  Value="1.0"/>
    <DefineVariable Name="BASE_SENS_MAX"  Value="1.3"/>
    <!-- Gate & smoothing -->
    <DefineVariable Name="DRIVE_GATE"     Value="0.18"/>   <!-- below => 0 -->
    <DefineVariable Name="DRIVE_LP_ALPHA" Value="0.94"/>   <!-- closer 1 = smoother -->
    <!-- Orbital base Hz (before AnimSpeed) -->
    <DefineVariable Name="BASE_ORB_HZ_MIN" Value="0.05"/>
    <DefineVariable Name="BASE_ORB_HZ_MAX" Value="0.35"/>
    <!-- AnimSpeed scalar -->
    <DefineVariable Name="BASE_AS_MIN"    Value="0.02"/>
    <DefineVariable Name="BASE_AS_DEF"    Value="0.18"/>
    <DefineVariable Name="BASE_AS_MAX"    Value="0.40"/>
    <!-- Smoothness (easing width) -->
    <DefineVariable Name="BASE_SM_MIN"    Value="0.0"/>
    <DefineVariable Name="BASE_SM_DEF"    Value="0.70"/>
    <DefineVariable Name="BASE_SM_MAX"    Value="1.0"/>

    <!-- Engine controls -->
    <DefineVariable Name="BASE_ORBS_MIN"  Value="0.20"/>
    <DefineVariable Name="BASE_ORBS_DEF"  Value="0.50"/>
    <DefineVariable Name="BASE_ORBS_MAX"  Value="1.20"/>

    <DefineVariable Name="BASE_DENS_MIN"  Value="0.50"/>
    <DefineVariable Name="BASE_DENS_DEF"  Value="1.25"/>
    <DefineVariable Name="BASE_DENS_MAX"  Value="2.50"/>

    <!-- Quality (step length multiplier): smaller = better -->
    <DefineVariable Name="BASE_Q_BEST"    Value="0.50"/>   <!-- best quality -->
    <DefineVariable Name="BASE_Q_DEF"     Value="1.00"/>
    <DefineVariable Name="BASE_Q_WORST"   Value="2.00"/>   <!-- worst quality -->

    <!-- Nucleus -->
    <DefineVariable Name="BASE_NR_MIN"    Value="0.03"/>
    <DefineVariable Name="BASE_NR_DEF"    Value="0.08"/>
    <DefineVariable Name="BASE_NR_MAX"    Value="0.15"/>

    <DefineVariable Name="BASE_NDOT_MIN"  Value="0.004"/>
    <DefineVariable Name="BASE_NDOT_DEF"  Value="0.016"/>
    <DefineVariable Name="BASE_NDOT_MAX"  Value="0.040"/>

    <!-- Color defaults (midpoint = DEF_*) and bounds for mapping -->
    <!-- Hue constants in degrees, shader uses normalized 0..1 -->
    <DefineVariable Name="DEF_BGH"  Value="210.0"/>
    <DefineVariable Name="DEF_BGS"  Value="0.45"/>
    <DefineVariable Name="DEF_BGL"  Value="0.015"/>
    <DefineVariable Name="DEF_BGA"  Value="1.0"/>

    <DefineVariable Name="DEF_PosH" Value="190.0"/>
    <DefineVariable Name="DEF_PosS" Value="0.90"/>
    <DefineVariable Name="DEF_PosL" Value="0.62"/>
    <DefineVariable Name="DEF_PosA" Value="1.0"/>

    <DefineVariable Name="DEF_NegH" Value="325.0"/>
    <DefineVariable Name="DEF_NegS" Value="0.85"/>
    <DefineVariable Name="DEF_NegL" Value="0.60"/>
    <DefineVariable Name="DEF_NegA" Value="1.0"/>

    <DefineVariable Name="DEF_ProtH" Value="28.0"/>
    <DefineVariable Name="DEF_ProtS" Value="0.95"/>
    <DefineVariable Name="DEF_ProtL" Value="0.72"/>
    <DefineVariable Name="DEF_ProtA" Value="1.0"/>

    <DefineVariable Name="DEF_NeutH" Value="260.0"/>
    <DefineVariable Name="DEF_NeutS" Value="0.65"/>
    <DefineVariable Name="DEF_NeutL" Value="0.75"/>
    <DefineVariable Name="DEF_NeutA" Value="1.0"/>

    <DefineVariable Name="DEF_ElecH" Value="190.0"/>
    <DefineVariable Name="DEF_ElecS" Value="0.98"/>
    <DefineVariable Name="DEF_ElecL" Value="0.92"/>
    <DefineVariable Name="DEF_ElecA" Value="1.0"/>

    <!-- ====== UI Sliders ====== -->
    <DefineArray Name="Parameters" SizeDim1="33"/>
    <DefineConstant Name="ParamHelpConst" Type="2"
      StringValue="Audio Gain&#10;Nucleus Sensitivity&#10;Orbital Sensitivity&#10;Smoothness&#10;Animation Speed&#10;Orbital Size&#10;Density Gain&#10;Nucleus Radius&#10;Nucleus Dot Size&#10;BG Hue&#10;BG Sat&#10;BG Light&#10;BG Alpha&#10;Proton Hue&#10;Proton Sat&#10;Proton Light&#10;Proton Alpha&#10;Neutron Hue&#10;Neutron Sat&#10;Neutron Light&#10;Neutron Alpha&#10;Electron Hue&#10;Electron Sat&#10;Electron Light&#10;Electron Alpha&#10;Orbital+ Hue&#10;Orbital+ Sat&#10;Orbital+ Light&#10;Orbital+ Alpha&#10;Orbital- Hue&#10;Orbital- Sat&#10;Orbital- Light&#10;Orbital- Alpha"/>

    <!-- ====== Runtime state / uniforms ====== -->
    <DefineVariable Name="Drive"     Value="0.0"/>
    <DefineVariable Name="DriveOrb"  Value="0.0"/>
    <DefineVariable Name="DriveNuc"  Value="0.0"/>
    <DefineVariable Name="NucSens"   Value="1.0"/>
    <DefineVariable Name="OrbSens"   Value="1.0"/>
    <DefineVariable Name="uTimeVar"  Value="0.0"/>
    <DefineVariable Name="Aspect"    Value="1.777778"/>

    <!-- exposed engine values (driven from sliders) -->
    <DefineVariable Name="Smooth"    Value="0.70"/>
    <DefineVariable Name="AnimSpeed" Value="0.18"/>
    <DefineVariable Name="OrbScale"  Value="0.50"/>
    <DefineVariable Name="Density"   Value="1.25"/>
    <DefineVariable Name="StepMul"   Value="1.00"/>
    <DefineVariable Name="NucR"      Value="0.08"/>
    <DefineVariable Name="NucDot"    Value="0.016"/>

    <!-- Phase integrator -->
    <DefineVariable Name="Phase"     Value="0.0"/>
    <DefineVariable Name="HzSmooth"  Value="0.10"/>

    <!-- HSLA uniforms -->
    <DefineVariable Name="uBGH" Value="0.583333"/>
    <DefineVariable Name="uBGS" Value="0.45"/>
    <DefineVariable Name="uBGL" Value="0.015"/>
    <DefineVariable Name="uBGA" Value="1.0"/>

    <DefineVariable Name="uPosH" Value="0.527778"/>
    <DefineVariable Name="uPosS" Value="0.90"/>
    <DefineVariable Name="uPosL" Value="0.62"/>
    <DefineVariable Name="uPosA" Value="1.0"/>

    <DefineVariable Name="uNegH" Value="0.902778"/>
    <DefineVariable Name="uNegS" Value="0.85"/>
    <DefineVariable Name="uNegL" Value="0.60"/>
    <DefineVariable Name="uNegA" Value="1.0"/>

    <DefineVariable Name="uProtH" Value="0.077778"/>
    <DefineVariable Name="uProtS" Value="0.95"/>
    <DefineVariable Name="uProtL" Value="0.72"/>
    <DefineVariable Name="uProtA" Value="1.0"/>

    <DefineVariable Name="uNeutH" Value="0.722222"/>
    <DefineVariable Name="uNeutS" Value="0.65"/>
    <DefineVariable Name="uNeutL" Value="0.75"/>
    <DefineVariable Name="uNeutA" Value="1.0"/>

    <DefineVariable Name="uElecH" Value="0.527778"/>
    <DefineVariable Name="uElecS" Value="0.98"/>
    <DefineVariable Name="uElecL" Value="0.92"/>
    <DefineVariable Name="uElecA" Value="1.0"/>

    <!-- ================= Shader ================= -->
    <Shader Name="ScreenShader">
      <VertexShaderSource><![CDATA[
#version 120
varying vec2 vUv;
void main(){
  vUv = gl_MultiTexCoord0.xy;
  gl_Position = ftransform();
}
      ]]></VertexShaderSource>

      <FragmentShaderSource><![CDATA[
#version 120
varying vec2 vUv;

uniform float uTime, uOrbDrive, uNucDrive, uSmooth, uAnimSpeed, uAspect, uPhase;

/* user uniforms */
uniform float uOrbScale, uDensity, uStepMul;
uniform float uNucR, uNucDot;

/* HSLA uniforms */
uniform float uBGH,uBGS,uBGL,uBGA;
uniform float uPosH,uPosS,uPosL,uPosA;
uniform float uNegH,uNegS,uNegL,uNegA;
uniform float uProtH,uProtS,uProtL,uProtA;
uniform float uNeutH,uNeutS,uNeutL,uNeutA;
uniform float uElecH,uElecS,uElecL,uElecA;

/* constants for volume render */
const float ZOOM=1.0;
const float HALF_Z=2.5;
const int   VOL_STEPS = 96;
const float STEP_LEN0 = (2.0*HALF_Z)/float(VOL_STEPS);

const float ORB_S_1S=0.80, ORB_S_2S=0.30, ORB_S_2P=0.25;

const float DENS_PEAK_GAIN=3.5;

const float PROTONS=8.0, NEUTRONS=8.0;
const float NUC_JITTER=0.35;

const int NUC_MAX=64;
const float TAU=6.28318530718;

/* utils */
float hash1(float x){ return fract(sin(x*113.3189)*43758.5453); }
vec3 hsl2rgb(vec3 h){
  float H=fract(h.x),S=clamp(h.y,0.0,1.0),L=clamp(h.z,0.0,1.0);
  float C=(1.0-abs(2.0*L-1.0))*S, X=C*(1.0-abs(mod(H*6.0,2.0)-1.0));
  vec3  rgb=(H<1./6.)?vec3(C,X,0):(H<2./6.)?vec3(X,C,0):(H<3./6.)?vec3(0,C,X):
             (H<4./6.)?vec3(0,X,C):(H<5./6.)?vec3(X,0,C):vec3(C,0,X);
  return rgb + (L-0.5*C);
}
vec2 uv01(){ return vUv; }
vec2 uvHNorm(){ return (uv01()*2.0 - 1.0) * vec2(uAspect,1.0); }

/* spherical harmonics l<=2 + simple radial */
void cart2sph(vec3 p, out float r, out float th, out float ph){
  r=length(p); th=(r>0.0)?acos(clamp(p.z/r,-1.0,1.0)):0.0; ph=atan(p.y,p.x);
}
float Y00(float th,float ph){return 1.0;}
float Y1m1(float th,float ph){return sin(th)*sin(ph);}
float Y10 (float th,float ph){return cos(th);}
float Y11 (float th,float ph){return sin(th)*cos(ph);}
float Y20 (float th,float ph){return 0.5*(3.0*cos(th)*cos(th)-1.0);}
float Y21 (float th,float ph){return sin(th)*cos(th)*cos(ph);} /* proxy */

float R10(float r){ return exp(-r); }
float R20(float r){ return (2.0 - r)*exp(-r*0.5); }
float R21(float r){ return r*exp(-r*0.5); }
float R32(float r){ return r*r*exp(-r/3.0); }

float famScale(int s){
  if(s==0) return ORB_S_1S;
  if(s==1) return ORB_S_2S;
  return ORB_S_2P;
}

float psiAt(int s, vec3 p, float drive){
  float sc = max(1e-3, uOrbScale * famScale(s));
  vec3  q  = p/sc;
  float r,th,ph; cart2sph(q,r,th,ph);
  if(s==0) return Y00(th,ph)*R10(r);
  if(s==1) return Y00(th,ph)*R20(r);
  if(s==2) return Y11(th,ph)*R21(r);
  if(s==3) return Y1m1(th,ph)*R21(r);
  return      Y10(th,ph)*R21(r);
}

float psiMix(vec3 p, float state, float drive){
  const int COUNT=5;
float idx=floor(state), t=fract(state);
  float tEase = mix(t, t*t*(3.0 - 2.0*t), uSmooth);
  float width = mix(0.20, 0.90, uSmooth);
  int s0=int(mod(idx, float(COUNT)));
  int s1=int(mod(idx+1.0, float(COUNT)));
  float a0=psiAt(s0,p,drive), a1=psiAt(s1,p,drive);
  float ts=smoothstep(0.5-width*0.5, 0.5+width*0.5, tEase);
  return mix(a0,a1,ts);
}

float densityAt(vec3 p, float state, float drive){
  float psi = psiMix(p, state, drive);
  float pos = max(psi, 0.0), neg = max(-psi, 0.0);
  return pos*pos + neg*neg;
}

/* colors */
vec3  bgRGB()   { return hsl2rgb(vec3(uBGH,uBGS,uBGL))*uBGA; }
vec3  posRGB()  { return hsl2rgb(vec3(uPosH,uPosS,uPosL))*uPosA; }
vec3  negRGB()  { return hsl2rgb(vec3(uNegH,uNegS,uNegL))*uNegA; }
vec4  protHSLA(){ return vec4(hsl2rgb(vec3(uProtH,uProtS,uProtL)), uProtA); }
vec4  neutHSLA(){ return vec4(hsl2rgb(vec3(uNeutH,uNeutS,uNeutL)), uNeutA); }
vec4  elecHSLA(){ return vec4(hsl2rgb(vec3(uElecH,uElecS,uElecL)), uElecA); }

vec3 nucleus(vec2 uv01){
  vec3 col=vec3(0.0); int NP=int(PROTONS+0.5), NN=int(NEUTRONS+0.5), NT=NP+NN;
  if(NT<1) return col; if(NT>NUC_MAX) NT=NUC_MAX;
  float drive = clamp(uNucDrive,0.0,1.0);
  drive = drive*drive*(3.0 - 2.0*drive);
  float jitter = NUC_JITTER * (1.0 + 2.5*drive) * mix(1.0, 0.4, uSmooth);
  vec4 pHSLA = protHSLA();
  vec4 nHSLA = neutHSLA();
  for(int k=0;k<NUC_MAX;k++){
    if(k>=NT) break;
    float m=float(k)+0.5;
    float z = 1.0 - 2.0*m/float(NT);
    float r = sqrt(max(0.0,1.0 - z*z));
    float th= 2.3999632297 * m;
    vec3 p = vec3(r*cos(th), r*sin(th), z) * uNucR;

    vec3 j = vec3(
      sin(1.9*uTime + 4.1*hash1(5.7*m)),
      sin(1.7*uTime + 3.3*hash1(7.9*m)),
      sin(2.1*uTime + 2.9*hash1(9.3*m))
    ) * (jitter * uNucR);
    p += j;

    vec2 n01 = (p.xy * ZOOM) / vec2(uAspect,1.0) * 0.5 + 0.5;
    float sigma = uNucDot * ZOOM;
    float d = length(uv01 - n01);
    float g = exp(-pow(d/(sigma+1e-6),2.0));
    vec3 c = (k<NP) ? pHSLA.rgb*pHSLA.a : nHSLA.rgb*nHSLA.a;
    col += c*g;
  }
  return col;
}

void main(){
  vec3 col = bgRGB();
  float d  = clamp(uOrbDrive, 0.0, 1.0);
  d = d*d*(3.0 - 2.0*d);
  float st = uPhase;

  float stepLen = STEP_LEN0 * max(0.5, uStepMul);
  float kComp   = STEP_LEN0 / stepLen;

  vec3  ro = vec3(uvHNorm()/max(ZOOM,1e-3), -HALF_Z);
  vec3  rd = vec3(0,0,1);
  float T  = 1.0;
  vec3  acc= vec3(0.0);

  vec3 cPos = posRGB();
  vec3 cNeg = negRGB();

  for(int i=0;i<VOL_STEPS;i++){
    float z = -HALF_Z + (float(i)+0.5)*stepLen;
    vec3  p = ro + rd*(z+HALF_Z);
    float psi = psiMix(p, st, d);
    float pos = max(psi, 0.0), neg = max(-psi, 0.0);
    float rPos= pos*pos, rNeg=neg*neg;

    float rho = (rPos + rNeg);

    float k    = uDensity * kComp;
    float a    = 1.0 - exp(-k * rho * stepLen);
    a = clamp(a, 0.0, 1.0);

    float wsum = rPos + rNeg + 1e-6;
    vec3  tint = (cPos*(rPos/wsum) + cNeg*(rNeg/wsum));

    float eps = stepLen;
    vec3 grad = vec3(
      densityAt(p + vec3(eps,0.0,0.0), st, d) - rho,
      densityAt(p + vec3(0.0,eps,0.0), st, d) - rho,
      densityAt(p + vec3(0.0,0.0,eps), st, d) - rho
    );
    float shade = 0.5 + 0.5 * max(dot(normalize(grad), normalize(vec3(1.0,1.0,1.0))), 0.0);

    vec3  contrib = tint * a * shade;
    acc += T * contrib;
    T   *= (1.0 - a);
    if(T < 0.02) break;
  }

  col += acc;
  col += nucleus(uv01());

  col = 1.0 - exp(-min(col, vec3(24.0)));
  col = pow(col, vec3(1.0/2.2));
  gl_FragColor = vec4(col,1.0);
}
      ]]></FragmentShaderSource>

      <UniformVariables>
        <ShaderVariable VariableName="uTime"       VariableRef="uTimeVar"/>
        <ShaderVariable VariableName="uOrbDrive"   VariableRef="DriveOrb"/>
        <ShaderVariable VariableName="uNucDrive"   VariableRef="DriveNuc"/>
        <ShaderVariable VariableName="uSmooth"     VariableRef="Smooth"/>
        <ShaderVariable VariableName="uAnimSpeed"  VariableRef="AnimSpeed"/>
        <ShaderVariable VariableName="uAspect"     VariableRef="Aspect"/>
        <ShaderVariable VariableName="uPhase"      VariableRef="Phase"/>

        <ShaderVariable VariableName="uOrbScale"   VariableRef="OrbScale"/>
        <ShaderVariable VariableName="uDensity"    VariableRef="Density"/>
        <ShaderVariable VariableName="uStepMul"    VariableRef="StepMul"/>

        <ShaderVariable VariableName="uNucR"       VariableRef="NucR"/>
        <ShaderVariable VariableName="uNucDot"     VariableRef="NucDot"/>

        <ShaderVariable VariableName="uBGH" VariableRef="uBGH"/>
        <ShaderVariable VariableName="uBGS" VariableRef="uBGS"/>
        <ShaderVariable VariableName="uBGL" VariableRef="uBGL"/>
        <ShaderVariable VariableName="uBGA" VariableRef="uBGA"/>

        <ShaderVariable VariableName="uPosH" VariableRef="uPosH"/>
        <ShaderVariable VariableName="uPosS" VariableRef="uPosS"/>
        <ShaderVariable VariableName="uPosL" VariableRef="uPosL"/>
        <ShaderVariable VariableName="uPosA" VariableRef="uPosA"/>

        <ShaderVariable VariableName="uNegH" VariableRef="uNegH"/>
        <ShaderVariable VariableName="uNegS" VariableRef="uNegS"/>
        <ShaderVariable VariableName="uNegL" VariableRef="uNegL"/>
        <ShaderVariable VariableName="uNegA" VariableRef="uNegA"/>

        <ShaderVariable VariableName="uProtH" VariableRef="uProtH"/>
        <ShaderVariable VariableName="uProtS" VariableRef="uProtS"/>
        <ShaderVariable VariableName="uProtL" VariableRef="uProtL"/>
        <ShaderVariable VariableName="uProtA" VariableRef="uProtA"/>

        <ShaderVariable VariableName="uNeutH" VariableRef="uNeutH"/>
        <ShaderVariable VariableName="uNeutS" VariableRef="uNeutS"/>
        <ShaderVariable VariableName="uNeutL" VariableRef="uNeutL"/>
        <ShaderVariable VariableName="uNeutA" VariableRef="uNeutA"/>

        <ShaderVariable VariableName="uElecH" VariableRef="uElecH"/>
        <ShaderVariable VariableName="uElecS" VariableRef="uElecS"/>
        <ShaderVariable VariableName="uElecL" VariableRef="uElecL"/>
        <ShaderVariable VariableName="uElecA" VariableRef="uElecA"/>
      </UniformVariables>
    </Shader>

    <Material Name="Mat" Shader="ScreenShader"/>

  </Content>

  <!-- ================= Init ================= -->
  <OnLoaded>
    <ZExpression><Expression><![CDATA[
Parameters[0]=0.5;
Parameters[1]=0.5;
Parameters[2]=0.5;
Parameters[3]=0.5;
Parameters[4]=0.5;
Parameters[5]=0.5;
Parameters[6]=0.5;
Parameters[7]=0.5;
Parameters[8]=0.5;
Parameters[9]=0.5;
Parameters[10]=0.5;
Parameters[11]=0.5;
Parameters[12]=0.5;
Parameters[13]=0.5;
Parameters[14]=0.5;
Parameters[15]=0.5;
Parameters[16]=0.5;
Parameters[17]=0.5;
Parameters[18]=0.5;
Parameters[19]=0.5;
Parameters[20]=0.5;
Parameters[21]=0.5;
Parameters[22]=0.5;
Parameters[23]=0.5;
Parameters[24]=0.5;
Parameters[25]=0.5;
Parameters[26]=0.5;
Parameters[27]=0.5;
Parameters[28]=0.5;
Parameters[29]=0.5;
Parameters[30]=0.5;
Parameters[31]=0.5;
Parameters[32]=0.5;
]]></Expression></ZExpression>
  </OnLoaded>

  <!-- ================= Per-frame ================= -->
  <OnRender>

    <!-- time -->
    <ZExpression><Expression><![CDATA[
uTimeVar = uTimeVar + 0.016;
]]></Expression></ZExpression>

    <!-- Smoothness -->
    <ZExpression><Expression><![CDATA[
float p = Parameters[3];
if (p < 0.5)
  Smooth = BASE_SM_MIN + (BASE_SM_DEF - BASE_SM_MIN) * (p * 2.0);
else
  Smooth = BASE_SM_DEF + (BASE_SM_MAX - BASE_SM_DEF) * (p * 2.0 - 1.0);
]]></Expression></ZExpression>

    <!-- Animation Speed -->
    <ZExpression><Expression><![CDATA[
float a = Parameters[4];
if (a < 0.5)
  AnimSpeed = BASE_AS_MIN + (BASE_AS_DEF - BASE_AS_MIN) * (a * 2.0);
else
  AnimSpeed = BASE_AS_DEF + (BASE_AS_MAX - BASE_AS_DEF) * (a * 2.0 - 1.0);
]]></Expression></ZExpression>

    <!-- Sensitivities -->
    <ZExpression><Expression><![CDATA[
float sN = Parameters[1];
if (sN < 0.5)
  NucSens = BASE_SENS_DEF * (sN * 2.0);
else
  NucSens = BASE_SENS_DEF + (BASE_SENS_MAX - BASE_SENS_DEF) * (sN * 2.0 - 1.0);
float sO = Parameters[2];
if (sO < 0.5)
  OrbSens = BASE_SENS_DEF * (sO * 2.0);
else
  OrbSens = BASE_SENS_DEF + (BASE_SENS_MAX - BASE_SENS_DEF) * (sO * 2.0 - 1.0);
]]></Expression></ZExpression>

    <!-- Audio drive (gain, gate, LP) -->
    <ZExpression><Expression><![CDATA[
float g = Parameters[0];
float gain = (g < 0.5) ? (BASE_GAIN_MIN + (BASE_GAIN_DEF - BASE_GAIN_MIN)*(g*2.0))
                       : (BASE_GAIN_DEF + (BASE_GAIN_MAX - BASE_GAIN_DEF)*(g*2.0-1.0));

/* 5-band average */
float b1=SpecBandArray[1];  if(b1<0.0)b1=-b1;
float b3=SpecBandArray[3];  if(b3<0.0)b3=-b3;
float b6=SpecBandArray[6];  if(b6<0.0)b6=-b6;
float b10=SpecBandArray[10];if(b10<0.0)b10=-b10;
float b15=SpecBandArray[15];if(b15<0.0)b15=-b15;
float sAvg = (b1+b3+b6+b10+b15)/5.0;

float raw = sAvg * gain;
if (raw < DRIVE_GATE) raw = 0.0;
if (raw > 1.0) raw = 1.0;

Drive = Drive * DRIVE_LP_ALPHA + raw * (1.0 - DRIVE_LP_ALPHA);
DriveNuc = clamp(Drive * NucSens, 0.0, 1.0);
DriveOrb = clamp(Drive * OrbSens, 0.0, 1.0);

/* integrate phase at slow rates */
float dOrb = DriveOrb;
dOrb = dOrb*dOrb*(3.0 - 2.0*dOrb);
float targetHz = (BASE_ORB_HZ_MIN + (BASE_ORB_HZ_MAX - BASE_ORB_HZ_MIN) * dOrb) * AnimSpeed;
HzSmooth = HzSmooth * 0.97 + targetHz * 0.03;
Phase    = Phase + HzSmooth * 0.016;
]]></Expression></ZExpression>

    <!-- Engine sliders -->
    <ZExpression><Expression><![CDATA[
float v;

/* Orbital size */
v = Parameters[5];
if (v < 0.5) OrbScale = BASE_ORBS_MIN + (BASE_ORBS_DEF - BASE_ORBS_MIN) * (v * 2.0);
else         OrbScale = BASE_ORBS_DEF + (BASE_ORBS_MAX - BASE_ORBS_DEF) * (v * 2.0 - 1.0);

/* Density gain */
v = Parameters[6];
if (v < 0.5) Density = BASE_DENS_MIN + (BASE_DENS_DEF - BASE_DENS_MIN) * (v * 2.0);
else         Density = BASE_DENS_DEF + (BASE_DENS_MAX - BASE_DENS_DEF) * (v * 2.0 - 1.0);

/* Nucleus radius */
v = Parameters[7];
if (v < 0.5) NucR = BASE_NR_MIN + (BASE_NR_DEF - BASE_NR_MIN) * (v * 2.0);
else         NucR = BASE_NR_DEF + (BASE_NR_MAX - BASE_NR_DEF) * (v * 2.0 - 1.0);

/* Nucleus dot size */
v = Parameters[8];
if (v < 0.5) NucDot = BASE_NDOT_MIN + (BASE_NDOT_DEF - BASE_NDOT_MIN) * (v * 2.0);
else         NucDot = BASE_NDOT_DEF + (BASE_NDOT_MAX - BASE_NDOT_DEF) * (v * 2.0 - 1.0);

]]></Expression></ZExpression>

    <!-- HSLA (0.5 = DEF_*) -->
    <ZExpression><Expression><![CDATA[
float q; float def;
/* BG */
def = DEF_BGH/360.0; q = Parameters[9];  if(q<0.5) uBGH = def*(q*2.0); else uBGH = def + (1.0-def)*(q*2.0-1.0);
q = Parameters[10]; if(q<0.5) uBGS = 0.0 + (DEF_BGS - 0.0)*(q*2.0); else uBGS = DEF_BGS + (1.0-DEF_BGS)*(q*2.0-1.0);
q = Parameters[11]; if(q<0.5) uBGL = 0.0 + (DEF_BGL - 0.0)*(q*2.0); else uBGL = DEF_BGL + (1.0-DEF_BGL)*(q*2.0-1.0);
q = Parameters[12]; if(q<0.5) uBGA = 0.0 + (DEF_BGA - 0.0)*(q*2.0); else uBGA = DEF_BGA + (1.0-DEF_BGA)*(q*2.0-1.0);
/* Proton */
def = DEF_ProtH/360.0; q = Parameters[13]; if(q<0.5) uProtH=def*(q*2.0); else uProtH=def + (1.0-def)*(q*2.0-1.0);
q = Parameters[14]; if(q<0.5) uProtS=0.0 + (DEF_ProtS-0.0)*(q*2.0); else uProtS=DEF_ProtS + (1.0-DEF_ProtS)*(q*2.0-1.0);
q = Parameters[15]; if(q<0.5) uProtL=0.0 + (DEF_ProtL-0.0)*(q*2.0); else uProtL=DEF_ProtL + (1.0-DEF_ProtL)*(q*2.0-1.0);
q = Parameters[16]; if(q<0.5) uProtA=0.0 + (DEF_ProtA-0.0)*(q*2.0); else uProtA=DEF_ProtA + (1.0-DEF_ProtA)*(q*2.0-1.0);
/* Neutron */
def = DEF_NeutH/360.0; q = Parameters[17]; if(q<0.5) uNeutH=def*(q*2.0); else uNeutH=def + (1.0-def)*(q*2.0-1.0);
q = Parameters[18]; if(q<0.5) uNeutS=0.0 + (DEF_NeutS-0.0)*(q*2.0); else uNeutS=DEF_NeutS + (1.0-DEF_NeutS)*(q*2.0-1.0);
q = Parameters[19]; if(q<0.5) uNeutL=0.0 + (DEF_NeutL-0.0)*(q*2.0); else uNeutL=DEF_NeutL + (1.0-DEF_NeutL)*(q*2.0-1.0);
q = Parameters[20]; if(q<0.5) uNeutA=0.0 + (DEF_NeutA-0.0)*(q*2.0); else uNeutA=DEF_NeutA + (1.0-DEF_NeutA)*(q*2.0-1.0);
/* Electron */
def = DEF_ElecH/360.0; q = Parameters[21]; if(q<0.5) uElecH=def*(q*2.0); else uElecH=def + (1.0-def)*(q*2.0-1.0);
q = Parameters[22]; if(q<0.5) uElecS=0.0 + (DEF_ElecS-0.0)*(q*2.0); else uElecS=DEF_ElecS + (1.0-DEF_ElecS)*(q*2.0-1.0);
q = Parameters[23]; if(q<0.5) uElecL=0.0 + (DEF_ElecL-0.0)*(q*2.0); else uElecL=DEF_ElecL + (1.0-DEF_ElecL)*(q*2.0-1.0);
q = Parameters[24]; if(q<0.5) uElecA=0.0 + (DEF_ElecA-0.0)*(q*2.0); else uElecA=DEF_ElecA + (1.0-DEF_ElecA)*(q*2.0-1.0);
/* Orbital+ */
def = DEF_PosH/360.0; q = Parameters[25]; if(q<0.5) uPosH=def*(q*2.0); else uPosH=def + (1.0-def)*(q*2.0-1.0);
q = Parameters[26]; if(q<0.5) uPosS=0.0 + (DEF_PosS-0.0)*(q*2.0); else uPosS=DEF_PosS + (1.0-DEF_PosS)*(q*2.0-1.0);
q = Parameters[27]; if(q<0.5) uPosL=0.0 + (DEF_PosL-0.0)*(q*2.0); else uPosL=DEF_PosL + (1.0-DEF_PosL)*(q*2.0-1.0);
q = Parameters[28]; if(q<0.5) uPosA=0.0 + (DEF_PosA-0.0)*(q*2.0); else uPosA=DEF_PosA + (1.0-DEF_PosA)*(q*2.0-1.0);
/* Orbital- */
def = DEF_NegH/360.0; q = Parameters[29]; if(q<0.5) uNegH=def*(q*2.0); else uNegH=def + (1.0-def)*(q*2.0-1.0);
q = Parameters[30]; if(q<0.5) uNegS=0.0 + (DEF_NegS-0.0)*(q*2.0); else uNegS=DEF_NegS + (1.0-DEF_NegS)*(q*2.0-1.0);
q = Parameters[31]; if(q<0.5) uNegL=0.0 + (DEF_NegL-0.0)*(q*2.0); else uNegL=DEF_NegL + (1.0-DEF_NegL)*(q*2.0-1.0);
q = Parameters[32]; if(q<0.5) uNegA=0.0 + (DEF_NegA-0.0)*(q*2.0); else uNegA=DEF_NegA + (1.0-DEF_NegA)*(q*2.0-1.0);
]]></Expression></ZExpression>

    <!-- Fullscreen draw via your scaling group -->
    <UseMaterial Material="Mat"/>
    <RenderTransformGroup Scale="20 20 1">
      <Children><RenderSprite/></Children>
    </RenderTransformGroup>

  </OnRender>
</ZApplication>
